[{"title":"Promise - 處理同步、非同步事件 - 2","url":"%2F2019%2F10%2F26%2F2019-10-25-Promise-%E8%99%95%E7%90%86%E5%90%8C%E6%AD%A5%E3%80%81%E9%9D%9E%E5%90%8C%E6%AD%A5%E4%BA%8B%E4%BB%B6-2%2F","content":"\n上一篇({% post_link 2019-10-25-Promise-處理同步、非同步事件-1 參考這邊 %})我們已經學習到如何簡單的建立 promise 物件來處理非同步、同步事件。但若我們想要傳入一些參數給 Promise 使用該怎麼辦呢？\n\n## 傳入參數給 Promise 使用\n\n![Promise 流程圖](https://i.imgur.com/PbcjInk.png)\n其實作法很簡單，我們只要建立一個 function 來包原本的 Promise 物件即可，以下我們同樣用跑步的範例來實作。\n我們先建立一個 function，並傳入一個參數`someone`，來指定誰要跑步（也可重複使用 Promise 指定不同跑者），寫入隨機產生是否要跑步及跑步秒數的變數，然後我們需要 return 一個透過建構式建立的 Promise，接下來就跟原本的建立方式差不多，利用 resolve() 及 reject() 來傳遞訊息，也可使用傳入的`someone`變數來指定跑者，最後使用 `then()`及 `catch()`來接收訊息。\n\n```javascript\n// 這次為了從外部引入資料，所以先建立 function 再 return Promise 物件\nlet running = someone => {\n  let run = Math.floor(Math.random() * 2); // 隨機產生 0 或 1\n  let duration = Math.floor(Math.random() * 10) + 1; // 隨機產生 0 ~ 10\n  console.log(\n    someone + ' ' + '考慮是否要跑步：' + run,\n    '預計跑步秒數：' + duration\n  );\n  // 建立 Promise 物件\n  return new Promise((resolve, reject) => {\n    if (run) {\n      window.setTimeout(() => {\n        resolve(someone + ' 跑了 ' + duration + ' 秒');\n      }, duration * 1000);\n    } else {\n      reject(someone + ' 不想跑了');\n    }\n  });\n};\nrunning('ASin')\n  .then(data => {\n    console.log(data);\n  })\n  .catch(data => {\n    console.log(data);\n  });\n```\n\n![Promise 外部帶入參數實作](https://i.imgur.com/eUabNzo.gif)\n\n## Promise.all( )、Promise.race( ) 傳入多個 Promise 事件\n\n有時候一個人跑步很無聊想找人陪伴，若是多個人跑步時那要怎麼操作呢？\n此時我們有兩種方法可以一次傳入多個 Promise 事件：\n\n- **all**：同時執行多個 Promise 事件，在**全部完成後統一將訊息以陣列回傳**。\n- **race**：同時執行多個 Promise 事件，這個方法**僅會回傳第一個完成的訊息**。\n\n以下我們同樣用上面範例的 Promise 物件來實作多個 Promise 事件。\n\n```javascript\nlet running = someone => {\n  let run = Math.floor(Math.random() * 2);\n  let duration = Math.floor(Math.random() * 10) + 1;\n  console.log(\n    someone + ' ' + '考慮是否要跑步：' + run,\n    '預計跑步秒數：' + duration\n  );\n  return new Promise((resolve, reject) => {\n    if (run) {\n      window.setTimeout(() => {\n        resolve(someone + ' 跑了 ' + duration + ' 秒');\n      }, duration * 1000);\n    } else {\n      reject(someone + ' 不想跑了');\n    }\n  });\n};\nrunning('ASin')\n  .then(data => {\n    console.log(data);\n  })\n  .catch(data => {\n    console.log(data);\n  });\n```\n\n### all\n\n使用 Promise.all( ) 並以陣列的方式傳入多個 Promise 物件，這邊傳入 ASin 及 Hyh 兩個 Promise，結果可以發現，這個方法會在全部完成後統一回傳陣列，而這個陣列的內容也是 promise 中 resolve 的內容。不過只要其中一個沒完成就會直接回傳 reject。\n\n```javascript\nPromise.all([running('ASin'), running('Hyh')])\n  .then(data => {\n    console.log(data);\n  })\n  .catch(data => {\n    console.log(data);\n  });\n```\n\n![Promise.all()](https://i.imgur.com/wbj8LGO.gif)\n\n### race\n\n使用 Promise.race( ) 並以陣列的方式傳入多個 Promise 物件，這邊傳入 ASin 及 Hyh 兩個 Promise，而這個方法只會回傳第一個完成的事件。不過只要其中一個沒完成就會直接回傳 reject。\n\n```javascript\nPromise.race([running('ASin'), running('Hyh')])\n  .then(data => {\n    console.log(data);\n  })\n  .catch(data => {\n    console.log(data);\n  });\n```\n\n![Promise.race()](https://i.imgur.com/XzEzlb4.gif)\n\n## Promise Chain 鏈結\n\n若是我們的 Promise 事件執行是有順序之分的，那麼該怎麼辦呢？\n當 ASin 跟 Hyh 一起跑步，但 Hyh 想先看 ASin 跑，她才要跑時，我們可以`then()`來鏈結 Promise 事件。\n首先，ASin 是第一個跑的，所以我們先執行 ASin 的跑步 Promise 事件，不同的是我們在 `console.log(data)`後又 return 了 Hyh 的 Promise 事件，然後我們在後面又用`then()`來接收 Hyh 的 Promise 事件訊息，也因此我們可以等待 ASin 這邊執行完以後，再來執行 Hyh，**用此方法就可以減少 Callback 問題，也可以依序執行不同的 promise 事件**。\n\n```javascript\nrunning('ASin')\n  .then(data => {\n    console.log(data);\n    return running('Hyh');\n  })\n  .then(data => {\n    console.log(data);\n  })\n  .catch(data => {\n    console.log(data);\n  });\n```\n\n![Promise Chain](https://i.imgur.com/3uqsKth.gif)\n","tags":["JavaScript"]},{"title":"Promise - 處理同步、非同步事件 - 1","url":"%2F2019%2F10%2F26%2F2019-10-25-Promise-%E8%99%95%E7%90%86%E5%90%8C%E6%AD%A5%E3%80%81%E9%9D%9E%E5%90%8C%E6%AD%A5%E4%BA%8B%E4%BB%B6-1%2F","content":"\n## callback hell\n\nJavaScript 中有很多非同步的事件，例如：AJAX、setTimeout、各種 event 事件(click,onchange…)等，由於 JavaScript 為單執行緒的程式語言（{% post_link 2019-10-22-為何setTimeout不一定會在1秒後執行呢？ 參考這邊 %}），這些事件我們很常使用 callback，在一層包一層後就會出現知名的 callback 地獄，而 ES6 開始新增了 Promise 物件就是為了解決此問題而生的。\n![](https://ithelp.ithome.com.tw/upload/images/20181014/201103713ObcIuaSP4.jpg)\n\n## Promise 的狀態與流程\n\nPromise 物件會有以下這幾種狀態：\n\n- pending: 等待中的初始狀態\n- fulfilled: 正確完成\n- rejected: 已拒絕，操作失敗\n\n剛進入 Promise 時，我們會進入 pending (等待事件完成)的狀態，接下來會依據事件的成功與否來回傳成功或拒絕的 callback，通常我們會使用 `resolve`、`reject` 兩個變數來傳送成功與失敗的訊息(資料)。\n\n```javascript\nlet myFirstPromise = new Promise((resolve, reject) => {\n  resolve(someValue); // fulfilled\n  reject('failure reason'); // rejected\n});\n```\n\n以下圖為範例，ASin 一開始在原地準備要跑步，此時他有兩種結果，一種是他正確的完成跑步這件事，最後他回報他跑了幾秒鐘；另一種結果是他拒絕跑步這件事，為什麼？他回報他就是不想跑步了。\n\n![Promise 流程圖](https://i.imgur.com/PbcjInk.png)\n我們將這整個過程寫成 Promise 物件來進行，可得以下的原始碼，首先，我們利用建構式建立一個 Promise 物件，並將此物件賦予給 running 這個變數，在 Promise 物件中引用 `resolve`、`reject` 變數來做 fulfilled 或 rejected 狀態時的訊息(資料)傳遞，在此我們寫了隨機產生是否要跑步及跑步秒數的變數，帶入我們的 if...else 陳述式，當 run 為 true (確定跑步,fulfilled)時，則調用 resolve() 來傳遞跑了幾秒鐘，若是 run 為 false，則調用 reject() 來傳遞不想跑了。\n\n```javascript\nlet running = new Promise((resolve, reject) => {\n  // 使用 resolve、reject 兩個變數來傳送訊息\n  let run = Math.floor(Math.random() * 2); // 隨機產生 0 或 1 同 false or true\n  let duration = Math.floor(Math.random() * 10) + 1; // 隨機產生 0 ~ 10\n  console.log('隨機是否要跑步：' + run, '預計跑步秒數：' + duration);\n  if (run) {\n    window.setTimeout(() => {\n      resolve('跑了' + duration + '秒');\n    }, duration * 1000);\n  } else {\n    reject('我不想跑了');\n  }\n});\nrunning\n  .then(data => {\n    console.log(data);\n  })\n  .catch(data => {\n    console.log(data);\n  });\n```\n\n最後，我們如何去執行這個物件來處理非同步與同步事件並接收訊息呢？\n我們可以使用 `then()`及 `catch()`來接收，從範例中可以看到，當 Promise 中執行的條件有滿足時，我們在`then()`傳入一個 function 並使用 data 變數來接收 fulfilled 狀態所傳遞的訊息，同樣的 rejected 狀態則是使用`catch()`來接收。\n![Promise執行結果-fulfilled](https://i.imgur.com/0b3qBN7.gif)\n![Promise執行結果-rejected](https://i.imgur.com/p62pdhH.gif)\n","tags":["JavaScript"]},{"title":"JavaScript核心概念 - 陳述式與表達式","url":"%2F2019%2F10%2F26%2F2019-10-26-%E9%99%B3%E8%BF%B0%E5%BC%8F%E8%88%87%E8%A1%A8%E9%81%94%E5%BC%8F%2F","content":"\n## 陳述式（Statement）\n\n用於命令或指定一系列的操作，要注意的是此語法<font color=red>**不會回傳一個結果**</font> 。例如：\n\n- 宣告 var, let, const,\n- 函式 function,\n- 迭代 for 迴圈,\n- 流程控制 if...else...\n\n......等等，可參考 [陳述式 MDN](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements)。\n\n## 表達式（Expression）\n\n又可稱為**表示式**與**運算式**，經常透過一些符號結合上下文並運算及<font color=red>**回傳一個結果**</font> 。可以分成兩種類型：\n\n- 運算式 a = 1 。 這個使用 = 運算子的運算式會將數值 1 賦與給 a。 運算式本身也會被解析為 a。\n- 運算式 1 + 2 。 這個運算式使用 + 運算子把 1 和 2 加起來，沒有將值賦予任何變數。\n\n可參考 [運算式與運算子 MDN](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Guide/Expressions_and_Operators) 內的運算式 part。\n\n## 陳述式不能作為值進行賦予\n\n以下範例為陳述式，語法並沒有錯誤也可以正常執行，但若我們將 if 陳述式賦予到 a 變數時，則會發生錯誤，這是因為我們上面提到的，陳述式並不會回傳一個結果，所以會發生錯誤。\n\n```javascript\n// 陳述式\nvar a\nif(1 === 1){\n\n}\n// 將陳述式賦予到變數上\na = if(1 === 1){\n\n}\n// 會跳錯\n```\n\n![](https://i.imgur.com/BBS3QnA.png)\n\n## 函式陳述式與函式表達式\n\n### 函式陳述式\n\n又稱為具名函式。我們這邊直接宣告一個函式並給予一個名稱，所以是函式的陳述式。\n\n```javascript\nfunction sayHello() {\n  console.log('Hello');\n}\n```\n\n### 函式表達式\n\n又稱為匿名函式。我們這邊先宣告一個變數，然後再把後面的函式**賦值**到變數上，所以是函式的表達式。\n\n```javascript\nvar sayHello = function() {\n  console.log('Hello');\n};\n```\n\n以上兩種函式在 hoisting 的結果會有差別，可以參考 {% post_link 2019-10-18-提升-hoisting%} 這篇。\n\n## Block 區塊與物件實字\n\nBlock 區塊屬於陳述式，可以用來定義 ES6 語法的作用域，例如 let 及 const，我們在 Block 中用 const 宣告一個常數，但在 Block 外調用 a 常數變數時，是無法取得的。\n最後，因為陳述式並不會 return 值，當然也無法賦予到變數上。\n\n```javascript\n// block 陳述式\n{\n  const a = 1\n}\nconsole.log(a) // 無法取得 a 變數\n// 賦值到變數上會跳錯， Uncaught SyntaxError: Unexpected identifier\nvar b = {\n  const a = 1\n}\n\n```\n\n![](https://i.imgur.com/C0m7WPN.png)\n下面的語法我們稱為**物件實字**，是 JavaScript 定義物件的一種方法，為函式表達式，因為他是表達式，會 return 一個值，而在這邊是 return 一個物件，所以我們可以賦予到變數上。\n\n```javascript\n// 物件實字 （JavaScript 定義物件的一種方法，為函式表達式）\n{\n  a: 1;\n}\n// 賦值到變數上是OK的，表達式會 return 一個物件\nvar c = {\n  a: 1\n};\n```\n","tags":["JavaScript"],"categories":["JavaScript核心概念"]},{"title":"JavaScript核心概念 - Not defined 、 undefined 、 null 的區分","url":"%2F2019%2F10%2F25%2F2019-10-25-Notdefined%E5%8F%8Aundefined%2F","content":"\n## undefined 與 null\n\n首先，我們要先瞭解，undefined 與 null 為基本型別之一，他們各自都只有一個值，就是 `undefined` 與 `null`，雖然這兩種值轉型成 boolean 時，都會代表 false 的意思，不過他們在意義上是有差別的。以下方的範例來說，我們在宣告變數時，**會在記憶體上先準備一個空間**給 ASin，若沒有賦予值，此時則會顯示為 `undefined` 。而 ASin2 直接賦予變數 一個 `null` 值，則此變數的值是**有明確定義的空值**。\n\n- undefined 是指「 還沒有賦予值，所以不知道是什麼 」\n- null 是指「 現在沒有值 」\n\n所以，我們若要賦予變數空值時，應採用 `null` 而不是 `undefined`。\n\n```javascript\nvar ASin;\nvar ASin2 = null;\nconsole.log(ASin); // undefined\nconsole.log(ASin2); // null\n```\n\n![](https://i.imgur.com/PJkiVVb.png)\n\n## not defined\n\n另外，not defined 就是我們根本沒有宣告變數，所以跳出錯誤。\n\n```javascript\n// var ASin;\nconsole.log(ASin); // Uncaught ReferenceError: ASin is not defined\n```\n\n![](https://i.imgur.com/mPz3dey.png)\n","tags":["JavaScript"],"categories":["JavaScript核心概念"]},{"title":"JavaScript核心概念 - 執行續、同步與非同步：為何setTimeout不一定會在1秒後執行呢？","url":"%2F2019%2F10%2F22%2F2019-10-22-%E7%82%BA%E4%BD%95setTimeout%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%9C%83%E5%9C%A81%E7%A7%92%E5%BE%8C%E5%9F%B7%E8%A1%8C%E5%91%A2%EF%BC%9F%2F","content":"\n首先，我們要知道 JavaScript 是一個單執行緒 (single threaded) 的程式語言，一次只會執行一段程式碼，執行環境會形成執行堆疊，執行完畢才將堆疊抽離，但在所有非同步事件如 click、setTimeout、ajax...，不會執行這樣的行為。\n<img src=\"https://i.imgur.com/OSzgoMJ.gif\" width=\"40%\" height=\"40%\"  style=\"margin: 0 auto;\"/>\n\n## 故事說明\n\nASin 剛買回來一份鹹酥雞，但想到剛剛學的 code 還沒練習完，想了想還是先練完再來吃好了，所以 ASin 會做以下的動作：\n\n- 掙扎了一下還是去練習寫 code\n- 開始練習 coding\n- 終於吃到鹹酥雞\n\n```javascript\nfunction Buyfood() {\n  var food = '鹹酥雞';\n\n  (function() {\n    console.log('先學習 code');\n    setTimeout(function() {\n      console.log('練習完可以吃' + food + '了');\n    }, 3000);\n  })();\n\n  (function() {\n    console.log('練習 coding');\n  })();\n}\n\nBuyfood(); // 執行\n\n// 先學習 code\n// 練習 coding\n// 練習完了可以吃鹹酥雞了\n```\n\n![](https://i.imgur.com/kCpiOhj.png)\n\n## Event queue\n\n我們可以看到 ASin 很認真的學習，將美味的鹹酥雞先擱置在一旁，這被擱置在一旁的鹹酥雞等待著 ASin 來享用在 JavaScript 稱為 Event queue。由於 setTimeout 是非同步執行，當 setTimeout 執行後其 callback function 會從堆疊中拖離，送到 Event queue，等待條件達成，但是，當條件達成時，Event queue 內的 callback function 還是要等待原本的執行堆疊都執行完後，才會被觸發。我們可以將上面的 setTimeout 改成 0 再來試試看：\n\n```javascript\nfunction Buyfood() {\n  var food = '鹹酥雞';\n\n  (function() {\n    console.log('先學習 code');\n    setTimeout(function() {\n      console.log('練習完可以吃' + food + '了');\n    }, 0);\n  })();\n\n  (function() {\n    console.log('練習 coding');\n  })();\n}\n\nBuyfood(); // 執行\n\n// 先學習 code\n// 練習 coding\n// 練習完了可以吃鹹酥雞了\n```\n\n我們還是會得到了同樣的結果。所以，當我們在為 setTimeout 設定時間條件時，其並不一定會在設定好的時間後就去執行，還是要看原執行堆疊的執行情況。\n","tags":["JavaScript"]},{"title":"JavaScript核心概念 - 提升(Hoisting)","url":"%2F2019%2F10%2F18%2F2019-10-18-%E6%8F%90%E5%8D%87-hoisting%2F","content":"\n## Handsome Man 怎可能不是我，這一定是有什麼誤會.....\n\n當我們宣告變數並取用時，有時候會發生 undefined 、 is not defined 或是取得的值跟想像中的不一樣，囧：\n\n```javascript\nvar HandsomeMan = '我';\nconsole.log(HandsomeMan);\n```\n\n![Variables Hoisting](https://i.imgur.com/AK3wWwz.png)\n......，Handsome Man 怎會是 undefined，Handsome Man 是我啊！！！\n\n```javascript\nconsole.log(HandsomeMan);\nvar HandsomeMan = '我';\n```\n\n![Variables Hoisting](https://i.imgur.com/qoM9qHg.png)\n\n```javascript\nconsole.log(HandsomeMan);\n```\n\n![Variables Hoisting](https://i.imgur.com/4XejTdB.png)\n此時就要考慮到是不是 **hoisting** 的關係。接下來我們將了解變數在宣告時會怎樣去執行。\n\n## 創造環境與執行\n\n在{% post_link 2019-10-17-執行環境與執行堆疊 執行環境與執行堆疊 %}這篇文章有講過，我們去執行程式碼時會建立執行環境，而執行環境的建立其實是有步驟的，首先，會先**創造環境**，變數在宣告時，會先將變數放到記憶體`key`的位置，如下圖 2 的 a、b、c 變數，**但在這個階段還不會賦予值給它**，在創造環境時就先在記憶體佔了一個位置，一直等到我們執行時才會賦予值，而這個流程我們稱為 **提升（hoisting）**。\n{% gp 3-1 %}\n![Variables Hoisting](https://i.imgur.com/zvyZSow.gif)\n![Variables Hoisting](https://i.imgur.com/lvwoX1V.gif)\n![Variables Hoisting](https://i.imgur.com/o5t2Yya.gif)\n{% endgp %}\n因此，我們可以將得到 `undefined` 結果的原始碼執行拆解為下列的步驟，在創造階段先於記憶體內建立 `HandsomeMan` 這個 `key` 的位置，然後我們就先執行 `console.log(HandsomeMan)`，但此時雖然已經將變數帶入到記憶體的 `key` 中，但是並沒有賦予它值，所以會得到 `undefined` 的結果。\n\n```javascript\nconsole.log(HandsomeMan);\nvar HandsomeMan = '我';\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓事實上執行步驟是這樣↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nvar HandsomeMan; // 創造階段\nconsole.log(HandsomeMan); // Handsome Man 是 undefined\nHandsomeMan = '我'; // 執行階段\n```\n\n至於，結果為 `is not defined` ，是根本沒有宣告變數，所以會有這樣的結果。\n\n## 函式陳述式在創造階段優先載入\n\n除了變數以外，我們在使用**函式陳述式**宣告變數時其優先權是不同的，從圖一可以看到函式陳述式在創造階段時就會優先載入進去記憶體，這個階段函式就已經可以完整的運行，下面我們舉一個範例來說明。\n{% gp 2-2 %}\n![](https://i.imgur.com/DIy9SQp.gif)\n![](https://i.imgur.com/QuExGch.gif)\n{% endgp %}\n\n### 在函式原始碼前執行函式\n\n當調用`callName()`是在函式原始碼前面時，由於函式在創造階段就已經將完整函式載入，所以載前面調用也可以完整地去執行。\n\n```javascript\ncallName(); // 悟空\nfunction callName() {\n  console.log('悟空');\n}\n```\n\n![](https://i.imgur.com/R6obtTh.png)\n\n### 函式陳述式與函式表達式在 Hoisting 的差異\n\n函式陳述式與函式表達式雖然都可以調用函式執行功能，但他們在建立時是有差異的，從範例中我們可以看到`callName()`有兩次調用，在第一次調用時，函式陳述式已經優先在創造階段完整載入，而函式表達式在創造階段雖然宣告`callName`變數，但這邊變數在重複宣告時是沒有用的，所以第一次的調用會得到`悟空`的結果，一直到了第二次調用時，函式表達式的變數已經賦予值，所以得到`悟飯`的結果。\n\n```javascript\ncallName();\nvar callName = function() {\n  // 函式表達式\n  console.log('悟飯');\n};\nfunction callName() {\n  // 函式陳述式\n  console.log('悟空');\n}\ncallName();\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓事實上執行步驟是這樣↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\n//創造階段\nfunction callName() {\n  // 函式陳述式\n  console.log('悟空');\n}\nvar callName;\n//執行階段\ncallName();\ncallName = function() {\n  // 函式表達式\n  console.log('悟飯');\n};\ncallName();\n```\n\n![](https://i.imgur.com/DBxQsWh.png)\n最後再來一個範例，在原始碼中兩個名稱相同函式陳述式後方都調用此函式，得到的結果都是哇沙米 🤮，這邊我們同樣利用創造階段與執行階段來區分，事實上在創造階段時，兩個函式都已經完整載入，但後面會覆蓋掉前面的，然後在執行階段執行了兩次函式都會是想吃哇沙米這個函式 🤮。\n\n```javascript\nfunction eatFood() {\n  console.log('想吃沙西米');\n}\neatFood();\nfunction eatFood() {\n  console.log('想吃哇沙米');\n}\neatFood();\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓事實上執行步驟是這樣↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\n//創造階段\nfunction eatFood() {\n  console.log('想吃沙西米');\n}\nfunction eatFood() {\n  console.log('想吃哇沙米');\n}\n//執行階段\neatFood();\neatFood();\n```\n\n![](https://i.imgur.com/1cUEVz6.png)\n\n## 總結\n\n記得變數與函式有 Hoisting 的特性，其流程可以分為**創造階段**及**執行階段**，函式在創造階段就會優先完整載入。\n","tags":["JavaScript"],"categories":["JavaScript核心概念"]},{"title":"JavaScript核心概念 - 範圍鍊","url":"%2F2019%2F10%2F18%2F2019-10-18-%E7%AF%84%E5%9C%8D%E9%8D%8A%2F","content":"\n## 再次思考作用域與執行環境的關係\n\n首先，若忘記語法作用域與執行環境可以先參考這兩篇（{% post_link 2019-10-17-語法作用域-LexicalScope 語法作用域 %}、{% post_link 2019-10-17-執行環境與執行堆疊 執行環境與執行堆疊 %}）。\n我們在語法作用域時有提到 callName（）的範例，因此我們可以得知 `CallName2()` 內在調用 `CallName1()` 時，`CallName1()`內的變數 `name` 會查找到全域變數的值 `ASin` ，所以我們了解到**在撰寫原始碼時就已經定義好它的作用域，與他的執行環境變沒有關聯**。\n\n```javascript\nvar name = 'ASin';\nfunction callName1() {\n  console.log(name);\n}\nfunction CallName2() {\n  var name = 'HYH';\n  callName1();\n}\nCallName2(); // ASin\n```\n\n## 範圍鍊\n\n延伸上面的範例，其實兩個 function 已經各自產生了一個範圍鍊，當本身的 function 內找不到變數時，會再往外層尋找，這樣將查找範圍又延伸到外層一層一層出去，就是範圍鍊的形成。痾....，這範圍好像有點短，我們再來看下面的範例。\n![範圍鍊](https://i.imgur.com/ODCknsn.png)\n\n```javascript\nvar person = 'ASin';\nfunction sayHello() {\n  console.log('Hello ' + person);\n}\nfunction meetSomeone() {\n  var person = '漂亮的HYH';\n  function meetHYH() {\n    function sayHelloToHYH() {\n      console.log('哈囉～ ' + person);\n    }\n    sayHelloToHYH();\n  }\n  sayHello();\n  meetHYH();\n}\nsayHello(); // Hello ASin\nmeetSomeone(); // Hello ASin & 哈囉～ 漂亮的HYH\n```\n\n- 當我們執行`sayHello()`時，由於函式內並沒有`person`這個變數，所以往外層全域來查找找到了 'ASin' 。\n- 那麼在執行`meetSomeone()`時，裡面調用了`sayHello()`，記得我們說過作用域早已經定義好了，雖然在`meetSomeone()`內調用，但它會忽視`var person = '漂亮的HYH'`，所以在`sayHello()`原始碼往外一層就是全域，同樣找到了'ASin'。\n- 接下來執行`meetHYH()`，裡面調用了`sayHelloToHYH()`，所以`sayHelloToHYH()`從他原始碼已定義好的作用域開始查找變數`person`，嗯...函式本身沒有`person`，再往外一層 → `meetHYH()`內.....還是沒有找到，再往外一層 → `meetSomeone()`內....發現`person`！！！終於讓我找到妳啦！所以 console 印出了`哈囉～ 漂亮的HYH`的結果。\n\n從`meetSomeone()`我們可以知道，當查找不到變數時會往外一層一層的找(範圍鍊)，而從哪裡開始查找則是看他已定義好的作用域，而不是執行環境。\n","tags":["JavaScript"],"categories":["JavaScript核心概念"]},{"title":"JavaScript核心概念 - 執行環境與執行堆疊","url":"%2F2019%2F10%2F17%2F2019-10-17-%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83%E8%88%87%E5%9F%B7%E8%A1%8C%E5%A0%86%E7%96%8A%2F","content":"\n## 執行環境\n\n我們在撰寫 function 原始碼時，就已經定義好它的作用域了，不過要等到我們去執行它時，它才會建立一個執行環境，而有這個執行環境時 function 作用域才有屬於它的變數。執行環境會在每次調用函式時建立，這個**執行環境會有限制作用域及產生 this 的特性**。那麼最外層呢？最外層當然就是我們的全域執行環境，這個全域執行環境會在我們一開始使用瀏覽器 or Node.js 開啟時即建立(this 會指向 window or global)。\n\n## 執行堆疊（Execution stack）\n\n這邊我們可以參照下面原始碼範例，當我們開啟瀏覽器進入畫面時，會先建立一個全域執行環境，然後我們執行 `doSomething()` ，此時會建立一個 `doSomething()` 的執行環境堆疊在全域上，接下來再調用 `sayHi()` 時， `sayHi()` 再建立一個執行環境堆的上去，形成執行環境的堆疊，最後當執行 `sayHi()` 執行完畢時則撤掉其執行環境，再接著撤掉 `doSomething()` 的執行環境，也結束我們的程式碼執行。\n\n<center class=\"half\">\n<img src=\"https://i.imgur.com/63i5BAi.gif\" width=\"40%\" height=\"40%\"  style=\"margin: 0 auto;\"/>\n<img src=\"https://i.imgur.com/OSzgoMJ.gif\" width=\"40%\" height=\"40%\"  style=\"margin: 0 auto;\"/>\n</center>\n```javascript\nfunction sayHi(name) {\n  var greeting = 'hi';\n  return greeting + ' ' + name;\n}\nfunction doSomething() {\n  var person = 'ASin';\n  console.log(sayHi(person));\n}\ndoSomething();\n```\n","tags":["JavaScript"],"categories":["JavaScript核心概念"]},{"title":"JavaScript核心概念 - 語法作用域（Lexical Scope）","url":"%2F2019%2F10%2F17%2F2019-10-17-%E8%AA%9E%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F-LexicalScope%2F","content":"\n## 變數宣告與作用域\n\n首先，我們要知道 JavaScript 的變數有它作用域的範圍，**未使用 var 所宣告的變數都會自動變成全域變數**，而**切分變數有效範圍的最小單位是 \"function\"** （ES6 之後有 let 與 const 分別定義「變數」與「常數」。 與 var 不同的是，它們的 scope 是透過大括號 { } 來切分的。）這邊我們舉一個例子，當我們將 `console.log(ASin)` 放在函式內執行函式時，其結果可以成功印出 '名字'，但若我們將其放在函式外時，其結果會顯示 ASin 這個變數並沒有被定義，這就是因為作用域的關係。\n\n```javascript\nfunction callName() {\n  var ASin = '名字';\n  console.log(ASin);\n}\ncallName(); // 名字\n```\n\n```javascript\nfunction callName() {\n  var ASin = '名字';\n}\nconsole.log(ASin); // Uncaught ReferenceError: ASin is not defined at <anonymous>\n```\n\n## 靜態作用域與動態作用域的差別\n\n**JavaScript 是採用靜態作用域(語法作用域)**，靜態作用域是**原始碼在透過直譯器解析語法時，就確定了它的作用域**，例如我們上面範例中 `console.log(ASin)` 在寫 function 時就已經定義好他的作用域。而動態作用域則是在函式調用的時候才決定它的作用域。\n\n![靜態作用域與動態作用域](https://i.imgur.com/IWF65C5.png)\n\n## JavaScript 作用域的查找\n\n在我們所寫的原始碼中最外層會有一個全域的作用域，然後是各個 function 所形成的作用域，各 function 間的作用域是獨立的。但是，當某個 function 內需要取用一個變數，而這個 function 內沒有這個變數時，就會向外查找，若有則取用，若沒有則會回報錯誤。\n![作用域](https://i.imgur.com/YMOSrwU.png)\n\n## 靜態作用域與動態作用域執行的結果\n\n所以當我們在寫好這些語法時，它的作用域就已經確定了，不會因為我們在執行時做改變。以下範例我們可以看到，`ASin` 的作用域在最外層，`HYH` 作用域只在 `CallName2()` 這個函式內，當我們執行 `CallName2()` 時，`CallName1()` 也會被調用並執行 `console.log(name)`，其結果會是 `ASin` 而不是 `HYH`，這邊我們要記得**我們在寫好語法時，它的作用域就已經確定了**，所以 `callName1()` 內沒有 `name` 這個變數因而往外層查找，得到 ASin 這個結果。\n\n那麼如果是動態作用域其情況就會不同，在調用`CallName2()`時，它會在函式宣告時才決定他的作用域，所以 `callName1()` 宣告時在 `CallName2()` 內，`CallName1()` 沒有 `name` 這個變數，所以往外層 `CallName2()` 查找，最後找到 `HYH`。\n\n```javascript\nvar name = 'ASin';\nfunction callName1() {\n  console.log(name);\n}\nfunction CallName2() {\n  var name = 'HYH'; //若為動態作用域時，callName1()取得 HYH\n  callName1();\n}\nCallName2(); // ASin\n```\n","tags":["JavaScript"],"categories":["JavaScript核心概念"]},{"title":"API（Application Programming Interface）-應用程式介面","url":"%2F2019%2F10%2F16%2F2019-10-16-API-Application-Programming-Interface%2F","content":"\n## 到底什麼是 API ?\n\nAPI（Application Programming Interface）中文翻譯為應用程式介面，霧煞煞啊！什麼鬼。若從中文翻譯介面兩字我們大概可以推測，這東西大概是會顯示一些資訊或是有一些功能可以給我們操作，就像拿著手機操作螢幕一樣。\n<img src=\"https://images.unsplash.com/photo-1521931961826-fe48677230a5?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=800&q=80\" width=\"50%\" height=\"50%\"  style=\"margin: 0 auto;\"/>\n而這個介面其實是給予我們串接用的，那為何要串接呢？以下舉個例子。\n在現今生活上我們常常使用一個東西來傳遞電腦資料叫做隨身碟（很多人會稱它為 USB，哈哈），幾乎所有的電腦都會有這個統一規格的 USB 插槽來讓你使用隨身碟存取或傳遞資料，API 也是這樣的概念，提供一個統一的介面，讓程式與程式之間做串接，我們就可以存取或傳遞資料。再舉一個例子。\n前陣子夾娃娃機非常的夯，同樣的機台與操作介面，裡面裝著許多不一樣的獎品，當我們透過搖桿利用正確的方式（有技巧方法？）去操作時，就可以順利取得我們想要的獎品。\n所以，在一些大型網站會提供一些功能性的 API 給我們做使用，例如：\n\n- Facebook: [串接 API 將你想發布的內容作為限時動態分享](https://developers.facebook.com/products#社交網站整合)\n- Google: [Googel 提供讓其他 APP 以 google 登入做驗證的 API](https://console.developers.google.com/)\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript核心概念 - LHS、RHS是什麼？","url":"%2F2019%2F10%2F16%2F2019-10-16-JavaScript%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-LHS%E3%80%81RHS%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F%2F","content":"\n## 原始碼語法錯誤\n\n首先，當我們在原始碼上使用到錯誤的語法時，console 都會顯示錯誤，這是原始碼在直譯器編譯過程中發生了錯誤。從下圖來看，我們在賦予字串這個值時，少了一個引號，`console.log` 則是少了括號，造成直譯器無法編譯。\n&nbsp;\n![原始碼語法錯誤](https://i.imgur.com/896UsRg.png)\n因此，我們在撰寫 JavaScript 時，可能會很常在變數與值的語法上發生一些錯誤，接下來我們將了解 LHS 和 RHS 概念，用來排除錯誤。\nLHS 和 RHS 概念是對變數與值的查詢、操作，其區分如下：\n\n- LHS (Left-hand Side)\n  - 用來賦予值到左側的變數上\n- RHS (Right-hand Side)\n  - 取得來自於右側變數上的值\n\n## LHS (Left-hand Side)\n\n從圖中的範例我們可以看到，在編譯過程中宣告一個變數並將值賦予到左側的變數上，這個過程稱為 LHS 。\n但是，若我們將左側改成字串，並賦予 1 這個值呢？\n我們可以發現 console 會出現錯誤，這個錯誤是指左邊的變數是無法被賦予的，因此當我們在開發時出現這樣的錯誤就可以對此進行修正。**另外，這段錯誤是屬於編譯過程中所發生的錯誤，在這樣的情形下會連編譯的結果都無法生成。**\n&nbsp;\n![LHS編譯錯誤](https://i.imgur.com/novMzfY.png)\n\n## RHS (Right-hand Side)\n\n從圖中的範例我們可以看到，宣告一個 `ASin` 變數並從右邊的 `style` 變數取得他的值，我們稱為 RHS，同樣的第一個 `console.log()` 從右邊的 `ASin` 取得值，並呈現在 console 中也是 RHS 。\n那 RHS 可能會發生什麼樣的錯誤呢？\n當我們 `console.log()`去取一個未宣告的變數時，他就會產生錯誤。但是，這邊要注意的是，我們可以發現 `console.log(ASi)` 是我們在輸入執行後才產生沒有定義的錯誤，並不是在編譯過程就產生錯誤，所以我們可以下一個結論，**RHS 在編譯過程中不會產生錯誤，而是在執行時才發現錯誤**。\n&nbsp;\n![RHS概念](https://i.imgur.com/USOiiUi.png)\n","tags":["JavaScript"],"categories":["JavaScript核心概念"]},{"title":"JavaScript核心概念 - JavaScript是如何運行？","url":"%2F2019%2F10%2F16%2F2019-10-16-JavaScript%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-JavaScript%E6%98%AF%E5%A6%82%E4%BD%95%E9%81%8B%E8%A1%8C%EF%BC%9F%2F","content":"\n\b\b 在瞭解 JavaScript 是如何運行前，我們要先瞭解在 script 中所寫的原始碼電腦是無法直接解讀的，這些語法都要轉換成電腦看得懂的代碼才有辦法運行，而語法的轉換則分成兩種，編譯式語言與直譯式語言：\n\n## 編譯式語言(Compiled language)\n\n在我們寫好原始碼時，會先透過編譯器(compiler)**預先編譯完成**並生成代碼，電腦才會解讀並執行，這樣的語言有下列幾項特色：\n\n- 編譯時即可除錯。\n- 預先定義的型別。\n- 型別檢查 (type check)。\n- 擁有高效能的執行速度等特性。\n- 可獨立執行。\n\n![編譯式語言](https://i.imgur.com/piO5rg7.png)\n\n## 直譯式語言(Interpreted language)\n\n不同於編譯式語言，直譯式語言在執行時會一行一行的動態將程式碼直譯為代碼，並執行，因此會有下列的特色：\n\n- 錯誤直接反映在環境上。\n- 不用預先定義的型別。\n- 動態生成。\n- 程式彈性。\n- 速度會比編譯式語言要慢一些。\n- 無法獨立運行，可用的功能由執行環境所提供。\n\n![直譯式語言](https://i.imgur.com/0ffPBoS.png)\n\n## JavaScript 直譯器的轉換過程\n\n在直譯器的轉換過程中，首先會將語法單元化（Tokenizing），然後透過抽象結構樹（Abstract Syntax Tree ）將原始碼的結構定義出來，最後生成代碼運行。\n![JavaScript直譯器轉換過程](https://i.imgur.com/l9LoxoY.png)\n接下來我們利用 <https://esprima.org/demo/parse.html> 來解析轉換得過程。\n\n### 語法單元化\n\n從下圖我們可以看到，我們所寫語法的每個單詞都會被單元化並解析為各種 type，例如 var 他並不會知道他有宣告變數的功能，而是辨識它為關鍵字，= 也不會知道它有賦予值的功能，而辨識它是一個標點符號。\n![語法單元化](https://i.imgur.com/HpWBe9D.png)\n\n### 抽象結構樹\n\n抽象結構樹會針對我們原本所要做的行為（這邊我們主要行為是宣告一個變數）來帶入不同的方法，在圖的下方有個 kind ，可以知道我們用來定義變數的方法是 var，若我們改成 ES6 中的 let 來宣告變數，則 kind 會變成 let。\n![抽象結構樹-宣告變數](https://i.imgur.com/TqmBcEG.png)\n![抽象結構樹-宣告變數](https://i.imgur.com/2fhZJXG.png)\n另外，我們知道當沒使用 var 宣告變數，而是直接對變數賦予值時會變成全域變數，從抽象結構樹也可以看到兩種方式的差別，一種是使用 VariableDeclarator 變數宣告的方法，直接賦予值是使用 AssignmentExpression 指派的方法。\n![抽象結構樹-宣告變數](https://i.imgur.com/yeOXKdA.png)\n","tags":["JavaScript"],"categories":["JavaScript核心概念"]},{"title":"JavaScript - 關於物件存取屬性的方法","url":"%2F2019%2F08%2F16%2F2019-8-16-about-assess-object's%20properties%2F","content":"\n## 點記法 (Dot notation)\n\n我們可透過點記法來存取物件的屬性與函式。為了存取物件內所*封裝*的東西，我們需要輸入物件名稱 (這裡是 person)，來作為*命名空間 (Namespace)*。接著寫一個「點」以及想存取的項目，可能是簡單屬性的名稱、陣列屬性的項目，又或是針對物件函式之一的呼叫。舉例來說：\n\n```javascript\nvar person = {\n  name: {\n    first: '弟弟',\n    last: '帥氣'\n  },\n  age: 20,\n  interests: ['打球', '看電視', '睡覺'],\n  sayHello: function() {\n    console.log('Hello')\n  }\n}\n```\n\n```javascript\nperson.age //目標物件的屬性，20\nperson.interests[1] //陣列屬性，看電視\nperson.sayHello() //呼叫函式，Hello\n```\n\n## 括弧記法 (Bracket notation)\n\n括弧記法則是另一個存取屬性的方法，是透過各屬性相關的名稱來選擇項目\n\n```javascript\nperson['age'] // 20\nperson['name']['first'] // 弟弟\n```\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript - 取得當前時間的方法","url":"%2F2019%2F08%2F12%2F2019-8-16-JavaScript%E5%8F%96%E5%BE%97%E7%95%B6%E5%89%8D%E6%99%82%E9%96%93%2F","content":"\n## 建立 Date( ) 物件\n\n在 JavaScript 中取得時間資訊需使用 Date() 物件來指向某一個時間點，透過物件內建的函式來取得相關資訊。\n取得時間的資訊有兩種方式，第一種是透過 Date.now() 來取得時間戳記（tiemstamp,毫秒），第二種是透過建構式建立 Date()物件，物件會回傳目前時間資訊的日期物件，然後就可以利用內建的函式來取得資訊。\n\n## Date( )內建函式\n\n以下為取得各資訊的函式：\n\n```javascript\nDate.now(); //  回傳當前的時間戳記timestamp（毫秒）\nlet today = new Date(); //  回傳目前時間的日期物件，利用today變數來儲存資訊\ntoday.getTime(); //  輸入時間物件，回傳特定時間的 timestamp（毫秒）\ntoday.getFullYear();\ntoday.getMonth(); //  回傳數值，取得月份，月份 0 表示 1 月！\ntoday.getDate(); //  回傳數值，取得幾號\ntoday.getDay(); //  回傳數值，取得星期幾\ntoday.getSeconds(); //  回傳數值，取得秒資訊\ntoday.getMinutes(); //  回傳數值，取得分資訊\ntoday.getHours(); //  回傳數值，取得小時資訊\n```\n\n## 利用建構式建立 Date( ) 物件取得時間\n\n範例：\n\n```javascript\nlet today = new Date(); //  回傳目前時間的日期物件\nlet yyyy = today.getFullYear();\n//這邊利用三元運算來補0\nlet mm = (today.getMonth() + 1 < 10 ? '0' : '') + (today.getMonth() + 1);\nlet dd = (today.getDate() < 10 ? '0' : '') + today.getDate();\nconsole.log(yyyy + '-' + mm + '-' + dd);\n```\n\n![範例結果](https://i.imgur.com/YO7rq2o.png)\n這邊要注意的是，在取得月份的時候，函式所回傳的資料是從 0 開始，也就是月份會回傳 0 ~ 11，代表 1 ~ 12 月，所以我們要自己補 1 才是正確的月份。\n另外，也可以透過三元運算來為個位數的月份及日來補 0 。\n\n## 將 TimeStamp 準換為其它表示方式\n\n最後，如果我們有一筆 timestamp 的資料要轉換成我們看得懂的格式，該如何做呢？\n只要將 timestamp 作為參數帶入 Date( ) 物件內即可（**注意 timestamp 要以毫秒為單位帶入**）\n\n```javascript\nlet timestamp = 1237648595747;\nlet day = new Date(timestamp);\nlet yyyy = day.getFullYear();\nlet mm = (day.getMonth() + 1 < 10 ? '0' : '') + (day.getMonth() + 1);\nlet dd = (day.getDate() < 10 ? '0' : '') + day.getDate();\nconsole.log(yyyy + '-' + mm + '-' + dd);\n```\n\n![範例結果](https://i.imgur.com/OYvtxoD.png)\n","tags":["JavaScript"],"categories":["JavaScript"]}]