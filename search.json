[{"title":"JavaScript核心概念-提升(Hoisting)","url":"%2F2019%2F10%2F18%2F2019-10-18-%E6%8F%90%E5%8D%87-hoisting%2F","content":"\n## Handsome Man 怎可能不是我，這一定是有什麼誤會.....\n\n當我們宣告變數並取用時，有時候會發生 undefined 、 is not defined 或是取得的值跟想像中的不一樣，囧：\n\n```javascript\nvar HandsomeMan = '我';\nconsole.log(HandsomeMan);\n```\n\n![Variables Hoisting](https://i.imgur.com/AK3wWwz.png)\n......，Handsome Man 怎會是 undefined，Handsome Man 是我啊！！！\n\n```javascript\nconsole.log(HandsomeMan);\nvar HandsomeMan = '我';\n```\n\n![Variables Hoisting](https://i.imgur.com/qoM9qHg.png)\n\n```javascript\nconsole.log(HandsomeMan);\n```\n\n![Variables Hoisting](https://i.imgur.com/4XejTdB.png)\n此時就要考慮到是不是 **hoisting** 的關係。接下來我們將了解變數在宣告時會怎樣去執行。\n\n## 創造環境與執行\n\n在{% post_link 2019-10-17-執行環境與執行堆疊 執行環境與執行堆疊 %}這篇文章有講過，我們去執行程式碼時會建立執行環境，而執行環境的建立其實是有步驟的，首先，會先**創造環境**，變數在宣告時，會先將變數放到記憶體`key`的位置，如下圖 2 的 a、b、c 變數，**但在這個階段還不會賦予值給它**，在創造環境時就先在記憶體佔了一個位置，一直等到我們執行時才會賦予值，而這個流程我們稱為 **提升（hoisting）**。\n{% gp 3-1 %}\n![Variables Hoisting](https://i.imgur.com/zvyZSow.gif)\n![Variables Hoisting](https://i.imgur.com/lvwoX1V.gif)\n![Variables Hoisting](https://i.imgur.com/o5t2Yya.gif)\n{% endgp %}\n因此，我們可以將得到 `undefined` 結果的原始碼執行拆解為下列的步驟，在創造階段先於記憶體內建立 `HandsomeMan` 這個 `key` 的位置，然後我們就先執行 `console.log(HandsomeMan)`，但此時雖然已經將變數帶入到記憶體的 `key` 中，但是並沒有賦予它值，所以會得到 `undefined` 的結果。\n\n```javascript\nconsole.log(HandsomeMan);\nvar HandsomeMan = '我';\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓事實上執行步驟是這樣↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nvar HandsomeMan; // 創造階段\nconsole.log(HandsomeMan); // Handsome Man 是 undefined\nHandsomeMan = '我'; // 執行階段\n```\n\n至於，結果為 `is not defined` ，是根本沒有宣告變數，所以會有這樣的結果。\n\n## 函式陳述式在創造階段優先載入\n\n除了變數以外，我們在使用**函式陳述式**宣告變數時其優先權是不同的，從圖一可以看到函式陳述式在創造階段時就會優先載入進去記憶體，這個階段函式就已經可以完整的運行，下面我們舉一個範例來說明。\n{% gp 2-2 %}\n![](https://i.imgur.com/DIy9SQp.gif)\n![](https://i.imgur.com/QuExGch.gif)\n{% endgp %}\n\n### 在函式原始碼前執行函式\n\n當調用`callName()`是在函式原始碼前面時，由於函式在創造階段就已經將完整函式載入，所以載前面調用也可以完整地去執行。\n\n```javascript\ncallName(); // 悟空\nfunction callName() {\n  console.log('悟空');\n}\n```\n\n![](https://i.imgur.com/R6obtTh.png)\n\n### 函式陳述式與函式表達式在 Hoisting 的差異\n\n函式陳述式與函式表達式雖然都可以調用函式執行功能，但他們在建立時是有差異的，從範例中我們可以看到`callName()`有兩次調用，在第一次調用時，函式陳述式已經優先在創造階段完整載入，而函式表達式在創造階段雖然宣告`callName`變數，但這邊變數在重複宣告時是沒有用的，所以第一次的調用會得到`悟空`的結果，一直到了第二次調用時，函式表達式的變數已經賦予值，所以得到`悟飯`的結果。\n\n```javascript\ncallName();\nvar callName = function() {\n  // 函式表達式\n  console.log('悟飯');\n};\nfunction callName() {\n  // 函式陳述式\n  console.log('悟空');\n}\ncallName();\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓事實上執行步驟是這樣↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\n//創造階段\nfunction callName() {\n  // 函式陳述式\n  console.log('悟空');\n}\nvar callName;\n//執行階段\ncallName();\ncallName = function() {\n  // 函式表達式\n  console.log('悟飯');\n};\ncallName();\n```\n\n![](https://i.imgur.com/DBxQsWh.png)\n最後再來一個範例，在原始碼中兩個名稱相同函式陳述式後方都調用此函式，得到的結果都是哇沙米 🤮，這邊我們同樣利用創造階段與執行階段來區分，事實上在創造階段時，兩個函式都已經完整載入，但後面會覆蓋掉前面的，然後在執行階段執行了兩次函式都會是想吃哇沙米這個函式 🤮。\n\n```javascript\nfunction eatFood() {\n  console.log('想吃沙西米');\n}\neatFood();\nfunction eatFood() {\n  console.log('想吃哇沙米');\n}\neatFood();\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓事實上執行步驟是這樣↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\n//創造階段\nfunction eatFood() {\n  console.log('想吃沙西米');\n}\nfunction eatFood() {\n  console.log('想吃哇沙米');\n}\n//執行階段\neatFood();\neatFood();\n```\n\n![](https://i.imgur.com/1cUEVz6.png)\n\n## 總結\n\n記得變數與函式有 Hoisting 的特性，其流程可以分為**創造階段**及**執行階段**，函式在創造階段就會優先完整載入。\n","tags":["JavaScript"],"categories":["JavaScript核心概念"]},{"title":"JavaScript核心概念-範圍鍊","url":"%2F2019%2F10%2F18%2F2019-10-18-%E7%AF%84%E5%9C%8D%E9%8D%8A%2F","content":"\n## 再次思考作用域與執行環境的關係\n\n首先，若忘記語法作用域與執行環境可以先參考這兩篇（{% post_link 2019-10-17-語法作用域-LexicalScope 語法作用域 %}、{% post_link 2019-10-17-執行環境與執行堆疊 執行環境與執行堆疊 %}）。\n我們在語法作用域時有提到 callName（）的範例，因此我們可以得知 `CallName2()` 內在調用 `CallName1()` 時，`CallName1()`內的變數 `name` 會查找到全域變數的值 `ASin` ，所以我們了解到**在撰寫原始碼時就已經定義好它的作用域，與他的執行環境變沒有關聯**。\n\n```javascript\nvar name = 'ASin';\nfunction callName1() {\n  console.log(name);\n}\nfunction CallName2() {\n  var name = 'HYH';\n  callName1();\n}\nCallName2(); // ASin\n```\n\n## 範圍鍊\n\n延伸上面的範例，其實兩個 function 已經各自產生了一個範圍鍊，當本身的 function 內找不到變數時，會再往外層尋找，這樣將查找範圍又延伸到外層一層一層出去，就是範圍鍊的形成。痾....，這範圍好像有點短，我們再來看下面的範例。\n![範圍鍊](https://i.imgur.com/ODCknsn.png)\n\n```javascript\nvar person = 'ASin';\nfunction sayHello() {\n  console.log('Hello ' + person);\n}\nfunction meetSomeone() {\n  var person = '漂亮的HYH';\n  function meetHYH() {\n    function sayHelloToHYH() {\n      console.log('哈囉～ ' + person);\n    }\n    sayHelloToHYH();\n  }\n  sayHello();\n  meetHYH();\n}\nsayHello(); // Hello ASin\nmeetSomeone(); // Hello ASin & 哈囉～ 漂亮的HYH\n```\n\n- 當我們執行`sayHello()`時，由於函式內並沒有`person`這個變數，所以往外層全域來查找找到了 'ASin' 。\n- 那麼在執行`meetSomeone()`時，裡面調用了`sayHello()`，記得我們說過作用域早已經定義好了，雖然在`meetSomeone()`內調用，但它會忽視`var person = '漂亮的HYH'`，所以在`sayHello()`原始碼往外一層就是全域，同樣找到了'ASin'。\n- 接下來執行`meetHYH()`，裡面調用了`sayHelloToHYH()`，所以`sayHelloToHYH()`從他原始碼已定義好的作用域開始查找變數`person`，嗯...函式本身沒有`person`，再往外一層 → `meetHYH()`內.....還是沒有找到，再往外一層 → `meetSomeone()`內....發現`person`！！！終於讓我找到妳啦！所以 console 印出了`哈囉～ 漂亮的HYH`的結果。\n\n從`meetSomeone()`我們可以知道，當查找不到變數時會往外一層一層的找(範圍鍊)，而從哪裡開始查找則是看他已定義好的作用域，而不是執行環境。\n","tags":["JavaScript"],"categories":["JavaScript核心概念"]},{"title":"JavaScript核心概念-執行環境與執行堆疊","url":"%2F2019%2F10%2F17%2F2019-10-17-%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83%E8%88%87%E5%9F%B7%E8%A1%8C%E5%A0%86%E7%96%8A%2F","content":"\n## 執行環境\n\n我們在撰寫 function 原始碼時，就已經定義好它的作用域了，不過要等到我們去執行它時，它才會建立一個執行環境，而有這個執行環境時 function 作用域才有屬於它的變數。執行環境會在每次調用函式時建立，這個**執行環境會有限制作用域及產生 this 的特性**。那麼最外層呢？最外層當然就是我們的全域執行環境，這個全域執行環境會在我們一開始使用瀏覽器 or Node.js 開啟時即建立(this 會指向 window or global)。\n\n## 執行堆疊（Execution stack）\n\n這邊我們可以參照下面原始碼範例，當我們開啟瀏覽器進入畫面時，會先建立一個全域執行環境，然後我們執行 `doSomething()` ，此時會建立一個 `doSomething()` 的執行環境堆疊在全域上，接下來再調用 `sayHi()` 時， `sayHi()` 再建立一個執行環境堆的上去，形成執行環境的堆疊，最後當執行 `sayHi()` 執行完畢時則撤掉其執行環境，再接著撤掉 `doSomething()` 的執行環境，也結束我們的程式碼執行。\n\n<center class=\"half\">\n<img src=\"https://i.imgur.com/63i5BAi.gif\" width=\"40%\" height=\"40%\"  style=\"margin: 0 auto;\"/>\n<img src=\"https://i.imgur.com/OSzgoMJ.gif\" width=\"40%\" height=\"40%\"  style=\"margin: 0 auto;\"/>\n</center>\n```javascript\nfunction sayHi(name) {\n  var greeting = 'hi';\n  return greeting + ' ' + name;\n}\nfunction doSomething() {\n  var person = 'ASin';\n  console.log(sayHi(person));\n}\ndoSomething();\n```\n","tags":["JavaScript"],"categories":["JavaScript核心概念"]},{"title":"JavaScript核心概念-語法作用域（Lexical Scope）","url":"%2F2019%2F10%2F17%2F2019-10-17-%E8%AA%9E%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F-LexicalScope%2F","content":"\n## 變數宣告與作用域\n\n首先，我們要知道 JavaScript 的變數有它作用域的範圍，**未使用 var 所宣告的變數都會自動變成全域變數**，而**切分變數有效範圍的最小單位是 \"function\"** （ES6 之後有 let 與 const 分別定義「變數」與「常數」。 與 var 不同的是，它們的 scope 是透過大括號 { } 來切分的。）這邊我們舉一個例子，當我們將 `console.log(ASin)` 放在函式內執行函式時，其結果可以成功印出 '名字'，但若我們將其放在函式外時，其結果會顯示 ASin 這個變數並沒有被定義，這就是因為作用域的關係。\n\n```javascript\nfunction callName() {\n  var ASin = '名字';\n  console.log(ASin);\n}\ncallName(); // 名字\n```\n\n```javascript\nfunction callName() {\n  var ASin = '名字';\n}\nconsole.log(ASin); // Uncaught ReferenceError: ASin is not defined at <anonymous>\n```\n\n## 靜態作用域與動態作用域的差別\n\n**JavaScript 是採用靜態作用域(語法作用域)**，靜態作用域是**原始碼在透過直譯器解析語法時，就確定了它的作用域**，例如我們上面範例中 `console.log(ASin)` 在寫 function 時就已經定義好他的作用域。而動態作用域則是在函式調用的時候才決定它的作用域。\n\n![靜態作用域與動態作用域](https://i.imgur.com/IWF65C5.png)\n\n## JavaScript 作用域的查找\n\n在我們所寫的原始碼中最外層會有一個全域的作用域，然後是各個 function 所形成的作用域，各 function 間的作用域是獨立的。但是，當某個 function 內需要取用一個變數，而這個 function 內沒有這個變數時，就會向外查找，若有則取用，若沒有則會回報錯誤。\n![作用域](https://i.imgur.com/YMOSrwU.png)\n\n## 靜態作用域與動態作用域執行的結果\n\n所以當我們在寫好這些語法時，它的作用域就已經確定了，不會因為我們在執行時做改變。以下範例我們可以看到，`ASin` 的作用域在最外層，`HYH` 作用域只在 `CallName2()` 這個函式內，當我們執行 `CallName2()` 時，`CallName1()` 也會被調用並執行 `console.log(name)`，其結果會是 `ASin` 而不是 `HYH`，這邊我們要記得**我們在寫好語法時，它的作用域就已經確定了**，所以 `callName1()` 內沒有 `name` 這個變數因而往外層查找，得到 ASin 這個結果。\n\n那麼如果是動態作用域其情況就會不同，在調用`CallName2()`時，它會在函式宣告時才決定他的作用域，所以 `callName1()` 宣告時在 `CallName2()` 內，`CallName1()` 沒有 `name` 這個變數，所以往外層 `CallName2()` 查找，最後找到 `HYH`。\n\n```javascript\nvar name = 'ASin';\nfunction callName1() {\n  console.log(name);\n}\nfunction CallName2() {\n  var name = 'HYH'; //若為動態作用域時，callName1()取得 HYH\n  callName1();\n}\nCallName2(); // ASin\n```\n","tags":["JavaScript"],"categories":["JavaScript核心概念"]},{"title":"API（Application Programming Interface）-應用程式介面","url":"%2F2019%2F10%2F16%2F2019-10-16-API-Application-Programming-Interface%2F","content":"\n## 到底什麼是 API ?\n\nAPI（Application Programming Interface）中文翻譯為應用程式介面，霧煞煞啊！什麼鬼。若從中文翻譯介面兩字我們大概可以推測，這東西大概是會顯示一些資訊或是有一些功能可以給我們操作，就像拿著手機操作螢幕一樣。\n<img src=\"https://images.unsplash.com/photo-1521931961826-fe48677230a5?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=800&q=80\" width=\"50%\" height=\"50%\"  style=\"margin: 0 auto;\"/>\n而這個介面其實是給予我們串接用的，那為何要串接呢？以下舉個例子。\n在現今生活上我們常常使用一個東西來傳遞電腦資料叫做隨身碟（很多人會稱它為 USB，哈哈），幾乎所有的電腦都會有這個統一規格的 USB 插槽來讓你使用隨身碟存取或傳遞資料，API 也是這樣的概念，提供一個統一的介面，讓程式與程式之間做串接，我們就可以存取或傳遞資料。再舉一個例子。\n前陣子夾娃娃機非常的夯，同樣的機台與操作介面，裡面裝著許多不一樣的獎品，當我們透過搖桿利用正確的方式（有技巧方法？）去操作時，就可以順利取得我們想要的獎品。\n所以，在一些大型網站會提供一些功能性的 API 給我們做使用，例如：\n\n- Facebook: [串接 API 將你想發布的內容作為限時動態分享](https://developers.facebook.com/products#社交網站整合)\n- Google: [Googel 提供讓其他 APP 以 google 登入做驗證的 API](https://console.developers.google.com/)\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript核心概念-LHS、RHS是什麼？","url":"%2F2019%2F10%2F16%2F2019-10-16-JavaScript%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-LHS%E3%80%81RHS%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F%2F","content":"\n## 原始碼語法錯誤\n\n首先，當我們在原始碼上使用到錯誤的語法時，console 都會顯示錯誤，這是原始碼在直譯器編譯過程中發生了錯誤。從下圖來看，我們在賦予字串這個值時，少了一個引號，`console.log` 則是少了括號，造成直譯器無法編譯。\n&nbsp;\n![原始碼語法錯誤](https://i.imgur.com/896UsRg.png)\n因此，我們在撰寫 JavaScript 時，可能會很常在變數與值的語法上發生一些錯誤，接下來我們將了解 LHS 和 RHS 概念，用來排除錯誤。\nLHS 和 RHS 概念是對變數與值的查詢、操作，其區分如下：\n\n- LHS (Left-hand Side)\n  - 用來賦予值到左側的變數上\n- RHS (Right-hand Side)\n  - 取得來自於右側變數上的值\n\n## LHS (Left-hand Side)\n\n從圖中的範例我們可以看到，在編譯過程中這邊宣告一個變數並將值賦予到左側的變數上，這個過程稱為 LHS 。\n但是，若我們將左側改成字串，並賦予 1 這個值呢？\n我們可以發現 console 會出現錯誤，這個錯誤是指左邊的變數是無法被賦予的，因此當我們在開發時出現這樣的錯誤就可以對此進行修正。**另外，這段錯誤是屬於編譯過程中所發生的錯誤，在這樣的情形下會連編譯的結果都無法生成。**\n&nbsp;\n![LHS編譯錯誤](https://i.imgur.com/novMzfY.png)\n\n## RHS (Right-hand Side)\n\n從圖中的範例我們可以看到，宣告一個 `ASin` 變數並從右邊的 `style` 變數取得他的值，我們稱為 RHS，同樣的第一個 `console.log()` 從右邊的 `ASin` 取得值，並呈現在 console 中也是 RHS 。\n那 RHS 可能會發生什麼樣的錯誤呢？\n當我們 `console.log()`去取一個未宣告的變數時，他就會產生錯誤。但是，這邊要注意的是，我們可以發現 `console.log(ASi)` 是我們在輸入執行後才產生沒有定義的錯誤，並不是在編譯過程就產生錯誤，所以我們可以下一個結論，**RHS 在編譯過程中不會產生錯誤，而是在執行時才發現錯誤**。\n&nbsp;\n![RHS概念](https://i.imgur.com/USOiiUi.png)\n","tags":["JavaScript"],"categories":["JavaScript核心概念"]},{"title":"JavaScript核心概念-JavaScript是如何運行？","url":"%2F2019%2F10%2F16%2F2019-10-16-JavaScript%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-JavaScript%E6%98%AF%E5%A6%82%E4%BD%95%E9%81%8B%E8%A1%8C%EF%BC%9F%2F","content":"\n\b\b 在瞭解 JavaScript 是如何運行前，我們要先瞭解在 script 中所寫的原始碼電腦是無法直接解讀的，這些語法都要轉換成電腦看得懂的代碼才有辦法運行，而語法的轉換則分成兩種，編譯式語言與直譯式語言：\n\n## 編譯式語言(Compiled language)\n\n在我們寫好原始碼時，會先透過編譯器(compiler)**預先編譯完成**並生成代碼，電腦才會解讀並執行，這樣的語言有下列幾項特色：\n\n- 編譯時即可除錯。\n- 預先定義的型別。\n- 型別檢查 (type check)。\n- 擁有高效能的執行速度等特性。\n- 可獨立執行。\n\n![編譯式語言](https://i.imgur.com/piO5rg7.png)\n\n## 直譯式語言(Interpreted language)\n\n不同於編譯式語言，直譯式語言在執行時會一行一行的動態將程式碼直譯為代碼，並執行，因此會有下列的特色：\n\n- 錯誤直接反映在環境上。\n- 不用預先定義的型別。\n- 動態生成。\n- 程式彈性。\n- 速度會比編譯式語言要慢一些。\n- 無法獨立運行，可用的功能由執行環境所提供。\n\n![直譯式語言](https://i.imgur.com/0ffPBoS.png)\n\n## JavaScript 直譯器的轉換過程\n\n在直譯器的轉換過程中，首先會將語法單元化（Tokenizing），然後透過抽象結構樹（Abstract Syntax Tree ）將原始碼的結構定義出來，最後生成代碼運行。\n![JavaScript直譯器轉換過程](https://i.imgur.com/l9LoxoY.png)\n接下來我們利用 <https://esprima.org/demo/parse.html> 來解析轉換得過程。\n\n### 語法單元化\n\n從下圖我們可以看到，我們所寫語法的每個單詞都會被單元化並解析為各種 type，例如 var 他並不會知道他有宣告變數的功能，而是辨識它為關鍵字，= 也不會知道它有賦予值的功能，而辨識它是一個標點符號。\n![語法單元化](https://i.imgur.com/HpWBe9D.png)\n\n### 抽象結構樹\n\n抽象結構樹會針對我們原本所要做的行為（這邊我們主要行為是宣告一個變數）來帶入不同的方法，在圖的下方有個 kind ，可以知道我們用來定義變數的方法是 var，若我們改成 ES6 中的 let 來宣告變數，則 kind 會變成 let。\n![抽象結構樹-宣告變數](https://i.imgur.com/TqmBcEG.png)\n![抽象結構樹-宣告變數](https://i.imgur.com/2fhZJXG.png)\n另外，我們知道當沒使用 var 宣告變數，而是直接對變數賦予值時會變成全域變數，從抽象結構樹也可以看到兩種方式的差別，一種是使用 VariableDeclarator 變數宣告的方法，直接賦予值是使用 AssignmentExpression 指派的方法。\n![抽象結構樹-宣告變數](https://i.imgur.com/yeOXKdA.png)\n","tags":["JavaScript"],"categories":["JavaScript核心概念"]},{"title":"JavaScript - 關於物件存取屬性的方法","url":"%2F2019%2F08%2F16%2F2019-8-16-about-assess-object's%20properties%2F","content":"\n## 點記法 (Dot notation)\n\n我們可透過點記法來存取物件的屬性與函式。為了存取物件內所*封裝*的東西，我們需要輸入物件名稱 (這裡是 person)，來作為*命名空間 (Namespace)*。接著寫一個「點」以及想存取的項目，可能是簡單屬性的名稱、陣列屬性的項目，又或是針對物件函式之一的呼叫。舉例來說：\n\n```javascript\nvar person = {\n  name: {\n    first: '弟弟',\n    last: '帥氣'\n  },\n  age: 20,\n  interests: ['打球', '看電視', '睡覺'],\n  sayHello: function() {\n    console.log('Hello')\n  }\n}\n```\n\n```javascript\nperson.age //目標物件的屬性，20\nperson.interests[1] //陣列屬性，看電視\nperson.sayHello() //呼叫函式，Hello\n```\n\n## 括弧記法 (Bracket notation)\n\n括弧記法則是另一個存取屬性的方法，是透過各屬性相關的名稱來選擇項目\n\n```javascript\nperson['age'] // 20\nperson['name']['first'] // 弟弟\n```\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript - 取得當前時間的方法","url":"%2F2019%2F08%2F12%2F2019-8-16-JavaScript%E5%8F%96%E5%BE%97%E7%95%B6%E5%89%8D%E6%99%82%E9%96%93%2F","content":"\n## 建立 Date( ) 物件\n\n在 JavaScript 中取得時間資訊需使用 Date() 物件來指向某一個時間點，透過物件內建的函式來取得相關資訊。\n取得時間的資訊有兩種方式，第一種是透過 Date.now() 來取得時間戳記（tiemstamp,毫秒），第二種是透過建構式建立 Date()物件，物件會回傳目前時間資訊的日期物件，然後就可以利用內建的函式來取得資訊。\n\n## Date( )內建函式\n\n以下為取得各資訊的函式：\n\n```javascript\nDate.now(); //  回傳當前的時間戳記timestamp（毫秒）\nlet today = new Date(); //  回傳目前時間的日期物件，利用today變數來儲存資訊\ntoday.getTime(); //  輸入時間物件，回傳特定時間的 timestamp（毫秒）\ntoday.getFullYear();\ntoday.getMonth(); //  回傳數值，取得月份，月份 0 表示 1 月！\ntoday.getDate(); //  回傳數值，取得幾號\ntoday.getDay(); //  回傳數值，取得星期幾\ntoday.getSeconds(); //  回傳數值，取得秒資訊\ntoday.getMinutes(); //  回傳數值，取得分資訊\ntoday.getHours(); //  回傳數值，取得小時資訊\n```\n\n## 利用建構式建立 Date( ) 物件取得時間\n\n範例：\n\n```javascript\nlet today = new Date(); //  回傳目前時間的日期物件\nlet yyyy = today.getFullYear();\n//這邊利用三元運算來補0\nlet mm = (today.getMonth() + 1 < 10 ? '0' : '') + (today.getMonth() + 1);\nlet dd = (today.getDate() < 10 ? '0' : '') + today.getDate();\nconsole.log(yyyy + '-' + mm + '-' + dd);\n```\n\n![範例結果](https://i.imgur.com/YO7rq2o.png)\n這邊要注意的是，在取得月份的時候，函式所回傳的資料是從 0 開始，也就是月份會回傳 0 ~ 11，代表 1 ~ 12 月，所以我們要自己補 1 才是正確的月份。\n另外，也可以透過三元運算來為個位數的月份及日來補 0 。\n\n## 將 TimeStamp 準換為其它表示方式\n\n最後，如果我們有一筆 timestamp 的資料要轉換成我們看得懂的格式，該如何做呢？\n只要將 timestamp 作為參數帶入 Date( ) 物件內即可（**注意 timestamp 要以毫秒為單位帶入**）\n\n```javascript\nlet timestamp = 1237648595747;\nlet day = new Date(timestamp);\nlet yyyy = day.getFullYear();\nlet mm = (day.getMonth() + 1 < 10 ? '0' : '') + (day.getMonth() + 1);\nlet dd = (day.getDate() < 10 ? '0' : '') + day.getDate();\nconsole.log(yyyy + '-' + mm + '-' + dd);\n```\n\n![範例結果](https://i.imgur.com/OYvtxoD.png)\n","tags":["JavaScript"],"categories":["JavaScript"]}]